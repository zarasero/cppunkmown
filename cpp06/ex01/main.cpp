/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: zserobia <zserobia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 19:37:14 by zserobia          #+#    #+#             */
/*   Updated: 2025/03/09 16:37:16 by zserobia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "Serializer.hpp"
#include <iostream>



int main() {
    // Создаем объект данных
    Data data = {42};

    // Сериализуем указатель на объект
    uintptr_t serializedData = Serializer::serialize(&data);
    std::cout << "Serialized address: " << serializedData << std::endl;

    // Десериализуем обратно
    Data* deserializedData = Serializer::deserialize(serializedData);
    std::cout << "Deserialized data: " << deserializedData->num << std::endl;

    return 0;
}


/*
int main() {
    // Создаем объекты Data
    Data myData1(42, "Example1");
    Data myData2(99, "Example2");
    
    // Сериализация первого объекта
    uintptr_t raw1 = Serializer::serialize(&myData1);
    
    // Десериализация первого объекта
    Data* deserializedPtr1 = Serializer::deserialize(raw1);
    
    // Проверка корректности
    if (deserializedPtr1 == &myData1) {
        std::cout << "Сериализация и десериализация успешны!" << std::endl;
        std::cout << "Данные: " << deserializedPtr1->id << ", " << deserializedPtr1->name << std::endl;
    } else {
        std::cout << "Ошибка: указатели не совпадают!" << std::endl;
    }

    // Сериализация второго объекта
    uintptr_t raw2 = Serializer::serialize(&myData2);
    
    // Десериализация второго объекта
    Data* deserializedPtr2 = Serializer::deserialize(raw2);
    
    // Проверка корректности
    if (deserializedPtr2 == &myData2) {
        std::cout << "Сериализация и десериализация успешны!" << std::endl;
        std::cout << "Данные: " << deserializedPtr2->id << ", " << deserializedPtr2->name << std::endl;
    } else {
        std::cout << "Ошибка: указатели не совпадают!" << std::endl;
    }

    return 0;
}

reinterpret_cast — это оператор приведения типов в C++, который позволяет осуществлять приведение типов на уровне битового представления. Этот оператор выполняет небезопасное приведение типов, преобразуя один тип в другой без каких-либо проверок или гарантии, что результат будет логически правильным.

Зачем нужен reinterpret_cast?
reinterpret_cast используется в случае, когда вы хотите провести приведение типов, которое не является логически совместимым, и оно не будет проверяться компилятором или временем выполнения. В отличие от других операторов приведения, таких как static_cast или dynamic_cast, reinterpret_cast не заботится о том, являются ли типы совместимыми. Он просто выполняет преобразование на уровне памяти.

В основном, reinterpret_cast применяется в низкоуровневом программировании, например, для:

Манипуляций с указателями и адресами.
Преобразования указателей между различными типами, когда вы знаете, что это безопасно (например, указатели на разные структуры данных, но с совместимыми представлениями в памяти).
Реализации некоторых алгоритмов и оптимизаций, требующих прямого контроля над памятью.
Особенности reinterpret_cast:
Безопасность: Он является небезопасным. Вы должны быть уверены, что преобразование имеет смысл, так как оно может привести к неопределенному поведению, если вы пытаетесь интерпретировать данные как другие типы, которые не имеют совместимую структуру.
Не проверяет совместимость типов: reinterpret_cast не проверяет, совместимы ли типы, как это делает static_cast. Он не проводит никаких проверок, а просто выполняет побитовое преобразование.
*/